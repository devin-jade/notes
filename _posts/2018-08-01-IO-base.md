---
layout: post
title: IO 多路复用
categories: [IO]
tags: IO
---

# IO 初识

 **IO (Input/Output，输入/输出)即数据的读取（接收）或写入（发送）操作，通常用户进程中的一个完整IO分为两阶段：用户进程空间<-->内核空间、内核空间<-->设备空间（磁盘、网络等）**。**IO有内存IO、网络IO和磁盘IO三种，通常我们说的IO指的是后两者。**

LINUX中进程无法直接操作I/O设备，其必须通过系统调用请求kernel来协助完成I/O动作；内核会为每个I/O设备维护一个缓冲区。对于一个输入操作来说，进程IO系统调用后，内核会先看缓冲区中有没有相应的缓存数据，没有的话再到设备中读取，因为设备IO一般速度较慢，需要等待；内核缓冲区有数据则直接复制到进程空间：

![](https://ws1.sinaimg.cn/large/9cd40bd3gy1g6tbjrdphvj20m0045gln.jpg)

很好的理解IO的关键是理解IO操作的两个阶段：

输入：

- 等待数据准备好，将数据放入内核缓存；
- 内核缓存数据完整之后，将内核缓存数据复制到用户的进程的地址空间内。

输出：

- 等待内核将缓存区的数据放到设备中，腾空缓存区；
- 缓存区有空间之后，将用户进程数据写入到内核缓存区。

无论是输入和输出都是分两个阶段完成，不同的IO模型就是对于两个阶段的不同处理方式的组合，目的就是满足某种使用场景，是的IO操作更高效。

## 名词解释

先把一些名词解释放在这，这些名词的含义说的是IO这个上下文，先混个脸熟，希望写完了可以完全理解。

阻塞调用和非阻塞调用：关注**进程在等待调用结果（消息、返回值）时的状态**，阻塞是指调用结果返回之前，当前进程会被挂起。调用进程只有在得到结果才会返回。非阻塞调用指不能立刻得到结果，该调用不会阻塞当前进程。通俗的说：请求不能立即得到应答，需要等待就是阻塞，否则就是非阻塞；

同步异步关注的是**进程之间的协作方式**，强调的是调用方获取结果的方式是主动的还是被动的。同步是A进程必须得到B进程通知才能去执行某件事（A执行），异步是指A进程通知B进程去执行然后立刻得到返回，然后就可以去做自己的事，B完成之后会给A发一个通知（B执行）。具体到IO这个上下文：针对应用程序和内核的交互而言，同步就是指用户进程需要等待IO或者主动轮询IO操作实付完成，异步就是用户进程出发IO操作后可以去干自己的事情，IO完成后，内核会主动通知用户进程。

仅仅从阻塞非阻塞，异步还是同步考虑根据上文可以知道：**I/O模型可以分为：同步阻塞，同步非阻塞，异步阻塞，异步非阻塞IO**

**同步阻塞IO**：在此种方式下，用户进程在发起一个IO操作以后，必须等待IO操作的完成，只有当真正完成了IO操作以后，用户进程才能运行。JAVA传统的IO模型属于此种方式！

**同步非阻塞IO**：在此种方式下，用户进程发起一个IO操作以后边可返回做其它事情，但是用户进程需要时不时的询问IO操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的CPU资源浪费。其中目前JAVA的NIO就属于同步非阻塞IO。

**异步阻塞IO**：此种方式下是指应用发起一个IO操作以后，不等待内核IO操作的完成，等内核完成IO操作以后会通知应用程序，这其实就是同步和异步最关键的区别，同步必须等待或者主动的去询问IO是否完成，那么为什么说是阻塞的呢？因为此时是通过select系统调用来完成的，而select函数本身的实现方式是阻塞的，而采用select函数有个好处就是它可以同时监听多个文件句柄（如果从UNP的角度看，select属于同步操作。因为select之后，进程还需要读写数据），从而提高系统的并发性！

**异步非阻塞IO**：在此种模式下，用户进程只需要发起一个IO操作然后立即返回，等IO操作真正的完成以后，应用程序会得到IO操作完成的通知，此时用户进程只需要对数据进行处理就好了，不需要进行实际的IO读写操作，因为真正的IO读取或者写入操作已经由内核完成了。目前Java中还没有支持此种IO模型。

不过如果根据IO的具体交互阶段去划分的的话，会有五种IO模型：

## 五种IO模型

>IO 有五种模式：
>
>- 阻塞IO：Blocking IO
>- 非阻塞IO：Non-Blocking IO
>- IO复用：IO Multiplexing
>- 信号驱动IO：Signal Driven IO 
>- 异步IO：Asynchrnous IO

### Blocking IO

**用户进程从发起调用一直阻塞直到数据准备完成** 

当用户进程调用了recvfrom这个系统调用，内核就开始了IO的第一个阶段：等待数据准备。对于network io来说，很多时候数据在一开始还没有到达（比如，还没有收到一个完整的UDP包），这个时候内核就要等待足够的数据到来。而在用户进程这边，整个进程会被阻塞。当内核一直等到数据准备好了，它就会将数据从内核中拷贝到用户内存，然后内核返回结果，用户进程才解除block的状态，重新运行起来。

![](https://ws1.sinaimg.cn/large/9cd40bd3gy1g6tbnacwvvj20fs09p3zp.jpg)

特点：

- **进程阻塞挂起不消耗CPU资源，及时响应每个操作**；

- 实现难度低、开发应用较容易；

- 适用并发量小的网络应用开发；

- **不适用并发量大的应用**：因为一个请求IO会阻塞进程，所以，得为每请求分配一个处理进程（线程）以及时响应，系统开销大。
- 例子：**阻塞socket、Java BIO；**

### Non-Blocking IO

**用户进程不用阻塞等待数据准备好，采用轮询的方式来检测数据是否准备完成** 

当用户进程调用recvfrom时，系统不会阻塞用户进程，而是立刻返回一个ewouldblock错误，从用户进程角度讲 ，并不需要等待，而是马上就得到了一个结果。用户进程判断标志是ewouldblock时，就知道数据还没准备好，于是它就可以去做其他的事了，于是它可以再次发送recvfrom，一旦内核中的数据准备好了。并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。

当一个应用程序在一个循环里对一个非阻塞调用recvfrom，我们称为轮询。应用程序不断轮询内核，看看是否已经准备好了某些操作。这通常是浪费CPU时间，但这种模式偶尔会遇到。

![](https://ws1.sinaimg.cn/large/9cd40bd3gy1g6tbtftjbgj20ha094wg7.jpg)

特点：

- 适用并发量较小、且不需要及时响应的网络应用开发；

- **进程轮询（重复）调用，消耗CPU的资源**；

- 实现难度低、开发应用相对阻塞IO模式较难；
- 例子：socket是非阻塞的方式（设置为NONBLOCK）

### IO Multiplexing:

**单个进程可以同时处理多个网络连接IO**

当用户进程调用了select，那么整个进程会被block，而同时，内核会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从内核拷贝到用户进程。 

这个图和blocking IO的图其实并没有太大的不同，事实上，还更差一些。因为这里需要使用两个system call (select 和 recvfrom)，而blocking IO只调用了一个system call (recvfrom)。但是，**用select的优势在于它可以以较少的代价同时处理多个connection。**（因此，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使用blocking IO的web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。） 

在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。

![](https://ws1.sinaimg.cn/large/9cd40bd3gy1g6udajj6ksj20gx092jsw.jpg)

特点：

- **专一进程解决多个进程IO的阻塞问题，性能好**；**Reactor模式;**
- 实现、开发应用难度较大；
- **适用高并发服务应用开发：一个进程（线程）响应多个请求**；
- 例子：**select、poll、epoll三种方案，nginx都可以选择使用这三个方案;****Java NIO**

### Signal Drive IO

**不常用，只有unix支持**

首先用户进程建立SIGIO信号处理程序，并通过系统调用sigaction执行一个信号处理函数，这时用户进程便可以做其他的事了，一旦数据准备好，系统便为该进程生成一个SIGIO信号，去通知它数据已经准备好了，于是用户进程便调用recvfrom把数据从内核拷贝出来，并返回结果。

与**I/O multiplexing (select and poll)**相比，它的优势是，免去了select的阻塞与轮询，当有活跃套接字时，由注册的handler处理。

![](https://ws1.sinaimg.cn/large/9cd40bd3gy1g6u6ko9idyj20fi09uq4b.jpg)

 1、特点：**回调机制，**实现、开发应用难度大；

### Asynchrnous IO

用户进程发起请求后得到立即返回，内核向用户进程发送最终结果

当用户进程向内核发起某个操作后，会立刻得到返回，并把所有的任务都交给内核去完成（包括将数据从内核拷贝到用户自己的缓冲区），内核完成之后，只需返回一个信号告诉用户进程已经完成就可以了。

![](https://ws1.sinaimg.cn/large/9cd40bd3gy1g6u6mallh4j20fw090dh1.jpg)

2、特点：

- **不阻塞，数据一步到位**；**Proactor模式**；
- 需要操作系统的底层支持，LINUX 2.5 版本内核首现，2.6 版本产品的内核标准特性；
- 实现、开发应用难度大；
- 非常适合高性能高并发应用；
- 例子：windows IOCP



### 小结：

各个IO模型的调用流程如图：

**上文提到，IO的操作分为连个阶段，阻塞，非阻塞指的是第一阶段，用户进程进行系统调用的时候是否需要挂起，同步和异步，指的是第二阶段用户进程是否需要主动的去将数据从内核拷贝到用户进程空间。**

 **BIO里用户最关心“我要读”，NIO里用户最关心”我可以读了”，在AIO模型里用户更需要关注的是“读完了”** 

从图中可以看出，前面四中IO都是需要用户进程，主动的完成第二阶段的操作因此都属于同步IO，他们的主要区别在于第一阶段，直接阻塞，立即返回+轮询，阻塞于select ，立即返回+信号处理程序.

从图中也可以看出，阻塞越来越少，理论上效率也会越来越高

![各种IO调用流程](https://ws1.sinaimg.cn/large/9cd40bd3gy1g6u6psfb4zj20j40a6di7.jpg)

写个不太恰当的小例子帮助理解：如果你想吃一份宫保鸡丁盖饭：

- 同步阻塞：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！
- 同步非阻塞：在饭馆点完餐，就去遛狗了。不过溜一会儿，就回饭馆喊一声：好了没啊！
- 异步阻塞：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。
- 异步非阻塞：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。



## 扩展

并发<Concurrent>：**而并发是指两个或多个事件在同一时间间隔内发生**。 **并发当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间 段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状，这种方式我们称之为并发(Concurrent)。**

并行<Parallel>：**指两个或者多个事件在同一时刻发生。**** **当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)**

串行:**指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。**

> **并行和串行指的是任务的执行方式。串行是指多个任务时，各个任务按顺序执行，完成一个之后才能进行下一个。并行指的是多个任务可以同时执行，异步是多个任务并行的前提条件。**



## 参考资料

[5种IO模型](https://blog.csdn.net/tjiyu/article/details/52959418)

[Comparing Two High-Performance I/O Design Patterns](http://www.artima.com/articles/io_design_patterns.html)

[Java NIO](https://www.jianshu.com/p/a6a38ed93fc2)







