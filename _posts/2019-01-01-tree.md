---
layout: post
title: 树的简述和存储结构
categories: [数据结构]
tags: 树

---

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/tree.png)

## 树的基本特性

树：一种非线性存储结构，存储一对多概念的数据元素集合；

结点：每一个数据元素称为一个节点。

父节点（双亲节点），子节点，兄弟节点： B 的父节点是A，兄弟节点是C,D，A的子节点是B,C,D

根节点：没有父节点的节点，一个树有且仅有一个根节点，A是根节点

叶子节点啊：没有任何子节点的节点。

度（Degree）：一个节点的度，节点的子树数，A 的度是3，三个子树；一棵树的度，树内各个节点的最大的度，比 	如树A的度是3；

深度：亦称高度，树中节点所在的最大层次，树的层是从1开始的。

有序树无序树，如果一颗树中从左向右看，谁在左边谁在右边，是有规定的，有序树，否则无序的；

森林：由m个互不相交的树组成的集合被称为森林。 B,C,D为根节点的三颗子树可以称之为森林；那么一个树就是一个根节点+森林组成的。

## 二叉树

二叉树：树的度小于等于2的有序树；

### 特征

1. 第i层最多有2^(i-1)个节点；

2. 深度为k的二叉树，最多有2^k-1个节点；

3. 终端节点数位n0,度为2的节点数为n2,则 n0= n2+1;

    3 的计算方法为：对于一个二叉树来说，除了度为 0 的叶子结点和度为 2 的结点，剩下的就是度为 1 的结点（设为 n1），那么总结点 n=n0+n1+n2。
   同时，对于每一个结点来说都是由其父结点分支表示的，假设树中分枝数为 B，那么总结点数 n=B+1。而分枝数是可以通过 n1 和 n2 表示的，即 B=n1+2*n2。所以，n 用另外一种方式表示为 n=n1+2*n2+1。
   两种方式得到的 n 值组成一个方程组，就可以得出 n0=n2+1。 
   
4. 具有n个节点的完全二叉树深度为 ⌊log2n⌋+1 ， ⌊X⌋ 表示不大于X的最大整数。

#### 斜树

所有节点只有左子树的二叉树树叫**左斜树**；所有的节点只有右子树的二叉树叫**右斜树**。统称**斜树**

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/20191024232544.png)

1. 每层只有一个节点；
2. 节点个数等于二叉树的深度相同；
3. 其实斜树和线性表结构是一样的，线性表结构其实是树的一种特殊形式。

####  满二叉树

没有度为1的节点，所有节点的度都为2，每个节点都拥有相同深度的子树,叶子节点都在底层；

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/20191024163031.png)

1. 满二叉树中第 i 层的节点数为 2^(n-1) 个。
2. 深度为 k 的满二叉树必有 2^k-1 个节点 ，叶子数为 2^(k-1)。
3. 具有 n 个节点的满二叉树的深度为 log2(n+1)。

#### 完全二叉树

出去最后一层叶子节点之后是个满二叉树，且最后一层节点依次从左到右分布；满二叉树是特殊的完全二叉树

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/20191024163358.png)

n个节点的完全二叉树深度：  ⌊log2n⌋+1 ； ⌊log2n⌋ 表示取小于 log2n 的最大整数 

1. 当 i>1 时，父亲结点为结点 ⌊i/2⌋ 。（i=1 时，表示的是根结点，无父亲结点）
2. 如果 2* i> n（总结点的个数） ，则结点 i 肯定没有左孩子（为叶子结点）；否则其左孩子是结点 2* i 。
3. 如果 2* i+1>n ，则结点 i 肯定没有右孩子；否则右孩子是结点 2*i+1 

### 二叉树的存储结构

#### 顺序存储

使用顺序表(数组)存储二叉树，只适用于完全二叉树；只有**完全二叉树才能使用顺序存储**，普通的树可以通过增加冗余节点转化为完全二叉树；

**仅需从根节点开始，按照层次依次将树中节点存储到数组即可。 ** 

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/20191024164410.png)

缺点：非完全二叉树需要填充冗余节点，浪费空间；插入和删除比较麻烦

优点：存储和还原都非常简单。随机访问效率高，可以通过下标访问，直接使用数组首部地址+偏移地址直接随机访问到；动态扩展性不好

#### 链式存储

使用链表存储二叉树

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/20191024164723.png)

这种结构给编程语言实现树结构提供了思路；

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/20191024165139.png)

- 指向左孩子节点的指针（Lchild）；
- 节点存储的数据（data）；
- 指向右孩子节点的指针（Rchild）；

 这种结构可以很好的将树节点串联存储起来，但是追溯父节点比较麻烦，所以诞生了三叉链表

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/20191024165352.png)

缺点：链式不支持随机访问，随机访问效率低

优点：扩容方便，插入和删除效率高；

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/20191024190128.png)

为了更好的存储树，树的常用存储结构是： **双亲表示法、孩子表示法、孩子兄弟表示法** 

#### 双亲表示法

除了根节点，每个节点可能没有子节点，但是肯定有父节点；

 一组连续空间存储树的结点，同时在每个结点中，**附设一个指示器指示其双亲结点到链表中的位置**即为双亲表示法。

|    data(数据域)    |          parent(指针域)          |
| :----------------: | :------------------------------: |
| 存储结点的数据信息 | 存储该结点的双亲所在数组中的下标 |

<img src="https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/20191024183632.png" style="zoom: 60%;" />

从存储结构上看：

1. 根节点没有双亲，因此约定 位置域的值为 **-1**
2. 遍历一个节点的父节点时很简单，时间复杂度是O(1)
3. 如果要找孩子结点，需要遍历整个结构才可以。

此方案可以改进，增加节点子节点的位置域，比如增加左节点位置域，解决找子节点的问题。

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/20191024184419.png)

对于除了关注子节点还要关注兄弟节点的场景来说，可以增加兄弟节点的位置域；

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/20191024184722.png)

总之，如果想要获取某个节点或者关系但是不想遍历整个树，那么就要将关系或者节点在存储结构里面存下来，空间换时间，但是要保存的越多，那么构建和维护就会变得复杂，所以要根据具体的使用场景来设计存储结构。

#### 孩子表示法

 **把每个结点的孩子结点排列起来，以单链表作存储结构，则n个结点有n个孩子链表，如果是叶子结点则此单链表为空。然后n个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中** 

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/20191024190021.png)

孩子表示法有两种结点结构：**孩子链表的孩子结点**和**表头数组的表头结点**

- 孩子链表的孩子结点

|         child(数据域)          |             next(指针域)             |
| :----------------------------: | :----------------------------------: |
| 存储某个结点在表头数组中的下标 | 存储指向某结点的下一个孩子结点的指针 |

- 表头数组的表头结点

|      data(数据域)      |     firstchild(头指针域)     |
| :--------------------: | :--------------------------: |
| 存储某个结点的数据信息 | 存储该结点的孩子链表的头指针 |

 这样的结构对于我们要查找某个结点的某个孩子，或者找某个结点的兄弟，只需要查找这个结点的孩子单链表即可。对于遍历整棵树也是很方便的，对头结点的数组循环即可。

但是如果需要去找节点的双亲节点，就要遍历整棵树了，不过双亲表示法恰好擅长这个，那就结合下呗，得到一种改进型** **双亲孩子表示法** **

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/20191024190749.png)

#### 孩子兄弟表示法

上面两种方法是从父节点和孩子节点的角度出发设计的，那么如果从兄弟节点考虑呢？任意一棵树，第一个节点和最后一个节点是唯一存在的，因此可以 设置两个指针，分别指向该结点的第一个孩子和此结点的右兄弟 。

|    data(数据域)    |        firstchild(指针域)        |         rightsib(指针域)         |
| :----------------: | :------------------------------: | :------------------------------: |
| 存储结点的数据信息 | 存储该结点的第一个孩子的存储地址 | 存储该结点的右兄弟结点的存储地址 |

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/20191024231240.png)

这个表示法的好处是其实已经把一颗复杂的树转成了一颗二叉树，做下变换，就得到了下图。

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/20191024231628.png)

## 参考

[大话数据结构](https://pan.baidu.com/s/1sEFpNZXsJMn5byUS4NwVZQ)



