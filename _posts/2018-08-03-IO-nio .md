---
layout: post
title: IO 进阶
categories: [IO]
tags: nio
---

从上文各个IO模型的特点看，NIO是高并发的不二之选，NIO的特点： socket主要的读、写、注册和接收函数，在等待就绪阶段都是非阻塞的，真正的I/O操作是同步阻塞的（消耗CPU但性能非常高） 。他主要用来结合事件模型来解放线程和提高吞吐量。

从上文中可以看到，在大型系统中，为了更高效的利用IO，IO复用和异步IO就成了不二选择，因此也就诞生了两种常用的复用模式，Reactor和Proactor。

一般地,I/O多路复用机制都依赖于一个事件**多路分离器(Event Demultiplexer)**。分离器对象可将来自事件源的I/O事件分离出来，并分发到对应的**read/write事件处理器(Event Handler)**。开发人员预先注册需要处理的事件及其事件处理器（或回调函数）；事件分离器负责将请求事件传递给事件处理器。

涉及到事件分发器的两种模式称为：Reactor和Proactor。 Reactor模式是基于同步I/O的，而Proactor模式是和异步I/O相关的。

在Reactor模式中，事件分发器等待某个事件或者可应用或个操作的状态发生（比如文件描述符可读写，或者是socket可读写），事件分发器就把这个事件传给事先注册的事件处理函数或者回调函数，由后者来做实际的读写操作。

而在Proactor模式中，事件处理者（或者代由事件分发器发起）直接发起一个异步读写操作（相当于请求），而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放读到数据的缓存区、读的数据大小或用于存放外发数据的缓存区，以及这个请求完后的回调函数等信息。事件分发器得知了这个请求，它默默等待这个请求的完成，然后转发完成事件给相应的事件处理者或者回调。举例来说，在Windows上事件处理者投递了一个异步IO操作（称为overlapped技术），事件分发器等IO Complete事件完成。这种异步模式的典型实现是基于操作系统底层异步API的，所以我们可称之为“系统级别”的或者“真正意义上”的异步，因为具体的读写是由操作系统代劳的。

举个例子，将有助于理解Reactor与Proactor二者的差异，以读操作为例（写操作类似）。

#### 在Reactor中实现读

- 注册读就绪事件和相应的事件处理器。
- 事件分发器等待事件。
- 事件到来，激活分发器，分发器调用事件对应的处理器。
- 事件处理器完成实际的读操作，处理读到的数据，注册新的事件，然后返还控制权。

#### 在Proactor中实现读：

- 处理器发起异步读操作（注意：操作系统必须支持异步IO）。在这种情况下，处理器无视IO就绪事件，它关注的是完成事件。
- 事件分发器等待操作完成事件。
- 在分发器等待过程中，操作系统利用并行的内核线程执行实际的读操作，并将结果数据存入用户自定义缓冲区，最后通知事件分发器读操作完成。
- 事件分发器呼唤处理器。
- 事件处理器处理用户自定义缓冲区中的数据，然后启动一个新的异步操作，并将控制权返回事件分发器。

可以看出，两个模式的相同点，都是对某个I/O事件的事件通知（即告诉某个模块，这个I/O操作可以进行或已经完成)。在结构上，两者也有相同点：事件分发器负责提交IO操作（异步)、查询设备是否可操作（同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下（Proactor)，当回调handler时，表示I/O操作已经完成；同步情况下（Reactor)，回调handler时，表示I/O设备可以进行某个操作（can read 或 can write)。

## Reactor

 用 “好莱坞原则” 来形容 Reactor 再合适不过了：不要打电话给我们，我们会打电话通知你。 

Reactor线程模型的思想是基于IO复用和线程池的结合。

Reactor 根据Reactor的数量和处理资源的线程数量的不同，分为三种线程模型，

>- 单Reactor单线程模型
>- 单Reactor多线程模型
>- 多Reactor多线程模型

### 单Reactor单线程模型

Reactor负责处理和分发时间，如果是连接事件就交给acceptor处理，如果是读写事件和业务处理就交给handler处理，但是始终只有一个线程执行所有的事情。

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/%E5%8D%95Reactor%E5%8D%95%E7%BA%BF%E7%A8%8B.png)

缺点：

>1. 仅用一个线程处理请求，对于多核资源机器来说是有点浪费的
>2. 当处理读写任务的线程负载过高后，处理速度下降，事件会堆积，严重的会超时，可能导致客户端重新发送请求，性能越来越差
>3. 单线程也会有可靠性的问题，单点问题

### 单Reactor多线程模型

Reactor只是负责处理连接事件和读写事件，业务处理交给线程池处理，充分利用多核机器的资源，提高性能并且增加可靠性。

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/20191102171702.png)

缺点：

>单reactor线程负责的工作依然较重，高并发下同样存在性能问题以及可靠性问题。

### 多Reactor多线程模型

将Reactor拆分为mainReactor和subReactor两个部分，前者只负责处理连接事件，读写事件交给subReactor来处理，业务逻辑交给线程池处理。

![](https://raw.githubusercontent.com/devin-jade/devin-imag/master/web/%E5%A4%9AReactor%E5%A4%9A%E7%BA%BF%E7%A8%8B.png)



mainRactor只处理连接事件，用一个线程来处理就好。处理读写事件的subReactor个数一般和CPU数量相等，一个subReactor对应一个线程，业务逻辑由线程池处理。因此这种模式也叫主从多线程版。



优点：模块职责单一，降低耦合度，性能和稳定性都有提高，此模型应用广泛，比如Netty就是采用了这种模型来处理。

### Reactor 读

> 1. 应用程序注册读就绪事件和相关联的事件处理器
> 2. 事件分离器等待事件的发生
> 3. 当发生读就绪事件的时候，事件分离器调用第一步注册的事件处理器
> 4. 事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理

## Proactor

### Proactor 读：

>1. 应用程序初始化一个异步读取操作（注意：操作系统必须支持异步IO），然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。
>2. 事件分离器等待读取操作完成事件
>3. 在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作（异步IO都是操作系统负责将数据读写到应用传递进来的缓冲区供应用程序操作，操作系统扮演了重要角色），并将读取的内容放入用户传递过来的缓存区中。这也是区别于Reactor的一点，Proactor中，应用程序需要传递缓存区。
>4. 事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。

从上面可以看出，Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序自己读取或者写入数据，而Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的IO设备，两个模式的相同点，都是对某个I/O事件的事件通知（即告诉某个模块，这个I/O操作可以进行或已经完成)。在结构上，两者也有相同点：事件分发器负责提交IO操作（异步)、查询设备是否可操作（同步)，然后当条件满足时，就回调handler；不同点在于，异步情况下（Proactor)，当回调handler时，表示I/O操作已经完成；同步情况下（Reactor)，回调handler时，表示I/O设备可以进行某个操作（can read 或 can write)。









## 参考资料

[Java NIO浅析](https://tech.meituan.com/2016/11/04/nio.html)

[用户态和内核态的理解和区别]( https://blog.csdn.net/qq_39823627/article/details/78736650 )

