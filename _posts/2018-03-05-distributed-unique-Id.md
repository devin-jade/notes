---
layout: post
title: 分布式ID生成器
categories: [Tool component]
tags: unique Id
---

# 分布式集群下如何做到唯一序列号

系统唯一ID是我们在分布式服务、微服务程序开发过程中常常会遇见的问题，也常常为这个问题而纠结。生成ID的方法有很多，适应不同的场景、需求以及性能要求。所以有些比较复杂的系统会有多个ID生成的策略。

ID生成器有其特殊要求：

1. 产生的ID不能重复，在任何情况下产生的ID都不能重复，例如：在ID生成器程序重启之后，ID生成器产生的新ID不能与重启之前产生的ID重复；
2. ID尽可能短小，由于很多情况下，ID需要被存储或者传输，因此在满足ID不重复的基础上ID长度尽可能短小，以降低存储或传输资源的浪费；
3.   支持高并发低延时请求；
4.   高可靠服务，在ID生成器的实际部署过程中，可能会遇到断电、断网、程序异常崩溃等等各种奇怪的问题，因此，如何能保证ID生成器提供稳定高效的服务，是分布式服务开发过程中，首先要解决的问题；
5.   在特殊场景中还不能通过ID看出公司的业务情况，比如用户ID或订单是自增的话，那么有心人士就可以看出公司每天的注册用户数或每日每月的订单总数；

###  数据库自增长序列或字段

最常见的方式。利用数据库，全数据库唯一。

优点：

1. 简单，代码方便，性能可以接受。
2. 数字ID天然排序，对分页或者需要排序的结果很有帮助。

缺点：

1. 不同数据库语法和实现不同，数据库迁移的时候或多数据库版本支持的时候需要处理。
2. 在单个数据库或读写分离或一主多从的情况下，只有一个主库可以生成。有单点故障的风险。
3. 在性能达不到要求的情况下，比较难于扩展。
4. 如果遇见多个系统需要合并或者涉及到数据迁移会相当痛苦。
5. 分表分库的时候会有麻烦。

优化：

1. 针对主库单点，如果有多个Master库，则每个Master库设置的起始数字不一样，步长一样，可以是Master的个数。比如：Master1 生成的是 1，4，7，10，Master2生成的是2,5,8,11 Master3生成的是 3,6,9,12。这样就可以有效生成集群中的唯一ID，也可以大大降低ID生成数据库操作的负载。
2. 为了解决性能问题，可以定义步长，比如数据库记录当前值1，步长1000，取出1000个数据，用完之后，更新当前值= 1+1000，重新获取下1000个；

例子：

Github:[]

### UUID

Universally Unique IDentifier(UUID)，RFC规范，一个128bit的数字,"8-4-4-4-12" 总共 36 个字符（32 个字母数字字符和 4 个连字符）。常见的方式。可以利用数据库也可以利用程序生成，一般来说全球唯一。

> 时间戳＋UUID版本号，分三段占16个字符(60bit+4bit);
>
> Clock Sequence号与保留字段，占4个字符(13bit＋3bit)，
>
> 节点标识占12个字符(48bit)，

比如：f81d4fae-7dec-11d0-a765-00a0c91e6bf6

标准中，UUID一共有五种版本：

> "版本1" UUID 是根据时间和节点 ID（通常是MAC地址）生成; 暴露MAC
>
> "版本2" UUID是根据标识符（通常是组或用户ID）、时间和节点ID生成; 基本不用
>
> "版本3" 和 "版本5" 确定性UUID 通过散列 (hashing) 名字空间 (namespace) 标识符和名称生成; 很少用
>
> "版本4" UUID 使用[随机性](https://zh.wikipedia.org/wiki/随机性)或[伪随机性](https://zh.wikipedia.org/wiki/伪随机性)生成。

能用于TraceId的是：版本1 和 版本4

优点：

1. 简单，代码方便。
2. 生成ID性能非常好，基本不会有性能问题。
3. 全球唯一，在遇见数据迁移，系统数据合并，或者数据库变更等情况下，可以从容应对。

 缺点：

1. 没有排序，无法保证趋势递增。
2. UUID往往是使用字符串存储，查询的效率比较低。
3. 存储空间比较大，如果是海量数据库，就需要考虑存储量的问题。
4. 传输数据量大
5. 不可读。

优化：

1. 为了解决UUID不可读，可以使用UUID to Int64
2. 为了解决UUID无序的问题，NHibernate在其主键生成方式中提供了Comb算法（combined guid/timestamp）。保留GUID的10个字节，用另6个字节表示GUID生成的时间（DateTime）

### Version1变种 – Hibernate

Hibernate的CustomVersionOneStrategy.java，解决了之前version 1的两个问题

\- 时间戳(6bytes, 48bit)：毫秒级别的，从1970年算起，能撑8925年….

\- 顺序号(2bytes, 16bit, 最大值65535): 没有时间戳过了一秒要归零的事，各搞各的，short溢出到了负数就归0。

\- 机器标识(4bytes 32bit): 拿localHost的IP地址，IPV4呢正好4个byte，但如果是IPV6要16个bytes，就只拿前4个byte。

\- 进程标识(4bytes 32bit)： 用当前时间戳右移8位再取整数应付，不信两条线程会同时启动。

### Version1变种 – MongoDB

MongoDB的ObjectId.java

\- 时间戳(4 bytes 32bit): 是秒级别的，从1970年算起，能撑136年。

\- 自增序列(3bytes 24bit, 最大值一千六百万)： 是一个从随机数开始（机智）的Int不断加一，也没有时间戳过了一秒要归零的事，各搞各的。因为只有3bytes，所以一个4bytes的Int还要截一下后3bytes。

\- 机器标识(3bytes 24bit): 将所有网卡的Mac地址拼在一起做个HashCode，同样一个int还要截一下后3bytes。搞不到网卡就用随机数混过去。

\- 进程标识(2bytes 16bits)：从JMX里搞回来到进程号，搞不到就用进程名的hash或者随机数混过去。

可见，MongoDB的每一个字段设计都比Hibernate的更合理一点，比如时间戳是秒级别的。总长度也降到了12 bytes 96bit，但如果果用64bit长的Long来保存有点不上不下的，只能表达成byte数组或16进制字符串。

### Redis生成ID

当使用数据库来生成ID性能不够要求的时候，我们可以尝试使用Redis来生成ID。这主要依赖于Redis是单线程的，所以也可以用生成全局唯一的ID。可以用Redis的原子操作 INCR和INCRBY来实现。

可以使用Redis集群来获取更高的吞吐量。假如一个集群中有5台Redis。可以初始化每台Redis的值分别是1,2,3,4,5，然后步长都是5。各个Redis生成的ID为：

A：1,6,11,16,21

B：2,7,12,17,22

C：3,8,13,18,23

D：4,9,14,19,24

E：5,10,15,20,25

这个，随便负载到哪个机确定好，未来很难做修改。但是3-5台服务器基本能够满足器上，都可以获得不同的ID。但是步长和初始值一定需要事先需要了。使用Redis集群也可以方式单点故障的问题。

另外，比较适合使用Redis来生成每天从0开始的流水号。比如订单号=日期+当日自增长号。可以每天在Redis中生成一个Key，使用INCR进行累加。 

优点：

1. 不依赖于数据库，灵活方便，且性能优于数据库。
2. 数字ID天然排序，对分页或者需要排序的结果很有帮助。

缺点：

1. 如果系统中没有Redis，还需要引入新的组件，增加系统复杂度。
2. 需要编码和配置的工作量比较大。

### Twitter的snowflake算法

snowflake算法

> snowflake是Twitter开源的分布式ID生成算法，结果是一个long型的ID。其核心思想是：使用41bit作为毫秒数，10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID），12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID），最后还有一个符号位，永远是0。

![img](https://note.youdao.com/yws/public/resource/7486133bc3c073349a8ee3ff53787b9c/xmlnote/70FF23C51DB142DFB6612FCC8E011430/7351)

> 阈值：
>
> - 41bit毫秒数，共有T（1llu << 41）毫秒分配，年份 = T / (3600 * 24 * 365 * 1000) = 69.7年；
> - 10bit机器ID，无论数据Id和机器ID怎么分配，实例最多1024个；
> - 12bit序列号，每毫秒峰值为4096个；
> - 单机每秒内理论上最多可以生成1000*(2^12)，也就是409.6万个ID；
> - 集群每秒内理论上最多可以生成1000x2^10x2^12，也就是4194304000个ID，41亿多；

思考：

1. 算法最终生成的是一个Long型的64bit数，是一种划分命名空间的算法，无论是时间位还是机器Id位都可以进行动态的调整，比如把毫秒位缩短，使用秒为单位，或者把机器数缩短和序列号字段缩短等等；
2. 总体思路其实就是在时间单位固定的情况下，尽可能的通过其他的位来区分Id，达到不可重复的原则；
3. 对于ID来讲，其实有全局和局部的概念，全局内唯一，局部和局部之间是可以相同的。

优点：

- 快（哈哈，天下武功唯快不破）。
- 没有啥依赖，实现也特别简单。
- 知道原理之后可以根据实际情况调整各各位段，方便灵活。

缺点：

- 只能趋势递增。
- 依赖机器时间，如果发生回拨会导致可能生成id重复。

关于时间回拨的问题：

美团的思路: Leaf——美团点评分布式ID生成系统（https://tech.meituan.com/MT_Leaf.html）思路是，如果时间发生回拨，就等待时间追上之后再生成新的ID。

百度的思路：uid-generator （https://github.com/baidu/uid-generator）。单独集中部署，机器不做时间同步，批量拉取，保证性能。

例子：

[GitHub]()

### **利用zookeeper生成唯一ID**

zookeeper主要通过其znode数据版本来生成序列号，可以生成32位和64位的数据版本号，客户端可以使用这个版本号来作为唯一的序列号。
很少会使用zookeeper来生成唯一ID。主要是由于需要依赖zookeeper，并且是多步调用API，如果在竞争较大的情况下，需要考虑使用分布式锁。因此，性能在高并发的分布式环境下，也不甚理想。

## 参考

[常用分布式ID方案](https://www.cnblogs.com/haoxinyue/p/5208136.html)

[Leaf——美团点评分布式ID生成系统](https://tech.meituan.com/2017/04/21/mt-leaf.html)

[snowflake算法思考](<https://mp.weixin.qq.com/s/WijbBrH_VWNTnCyWrL0IbA>)

[Twitter-Snowflake](https://www.lanindex.com/twitter-snowflake%EF%BC%8C64%E4%BD%8D%E8%87%AA%E5%A2%9Eid%E7%AE%97%E6%B3%95%E8%AF%A6%E8%A7%A3/)

[Leaf：美团分布式ID生成服务开源](https://tech.meituan.com/2019/03/07/open-source-project-leaf.html)



[通用唯一识别码](https://zh.wikipedia.org/wiki/通用唯一识别码)